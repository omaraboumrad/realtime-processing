<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Real-time Image Processing Demo</title>
        <script src="https://cdn.tailwindcss.com"></script>
    </head>
    <body class="bg-gray-100 min-h-screen p-8">
        <div class="max-w-6xl mx-auto space-y-6">
            <div class="grid grid-cols-2 gap-6">
                <!-- Left Panel: File Upload and List -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <input type="file"
                           id="fileInput"
                           accept="image/*"
                           multiple
                           onchange="uploadFiles()"
                           class="block w-full text-sm text-gray-900 border border-gray-300 rounded-lg cursor-pointer bg-gray-50 focus:outline-none p-2 mb-4">
                    <div class="flex items-center justify-between mb-3">
                        <h3 class="text-xl font-semibold">Uploaded Images</h3>
                        <button onclick="processAll()"
                                class="bg-green-500 hover:bg-green-600 text-white p-2 rounded transition"
                                title="Process All">
                            <svg xmlns="http://www.w3.org/2000/svg" class="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                                <path d="M4 18l8.5-6L4 6v12zm2-8.14L10.03 12 6 14.14V9.86zM21.5 12L13 6v12l8.5-6zM15 9.86L19.03 12 15 14.14V9.86z"/>
                            </svg>
                        </button>
                    </div>
                    <div id="imageList" class="space-y-3 max-h-96 overflow-y-auto">
                        <!-- Images will be dynamically added here -->
                    </div>
                </div>
                <!-- Right Panel: WebSocket Log -->
                <div class="bg-white rounded-lg shadow-lg p-6">
                    <h2 class="text-2xl font-bold mb-4">Message Log</h2>
                    <div id="messageLog"
                         class="bg-gray-50 rounded-lg p-4 h-[500px] overflow-y-auto font-mono text-sm">
                        <!-- Messages will be logged here -->
                    </div>
                </div>
            </div>
            <!-- Image Preview Panel -->
            <div id="imagePreviewPanel"
                 class="hidden bg-white rounded-lg shadow-lg p-6">
                <div class="flex justify-between items-center mb-4">
                    <h2 id="imagePreviewCaption" class="text-xl font-bold">Image Preview</h2>
                    <button onclick="closePreview()"
                            class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
                </div>
                <div class="flex justify-center">
                    <img id="previewImage"
                         src=""
                         alt="Image preview"
                         class="max-h-96 rounded-lg">
                </div>
            </div>
        </div>

        <!-- Templates -->
        <template id="imageItemTemplate">
            <div class="image-item border rounded p-2 bg-gray-50 flex items-center gap-2 text-sm">
                <span class="image-id font-semibold text-gray-700 shrink-0"></span>
                <span class="image-filename text-gray-600 text-sm truncate max-w-[150px]"></span>
                <span class="image-status"></span>
                <div class="flex-1"></div>
                <button class="btn-source bg-blue-500 hover:bg-blue-600 text-white text-xs font-semibold px-2 py-1.5 rounded transition hidden" title="View Original">SRC</button>
                <button class="btn-result bg-purple-500 hover:bg-purple-600 text-white text-xs font-semibold px-2 py-1.5 rounded transition hidden" title="View Processed">RES</button>
                <button class="btn-process bg-green-500 hover:bg-green-600 text-white p-1.5 rounded transition hidden" title="Process">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
                <button class="btn-delete bg-red-500 hover:bg-red-600 text-white p-1.5 rounded transition" title="Delete">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 6h18M8 6V4h8v2m-9 0v12a2 2 0 002 2h6a2 2 0 002-2V6"/>
                    </svg>
                </button>
                <button class="btn-replay bg-orange-500 hover:bg-orange-600 text-white p-1.5 rounded transition" title="Duplicate">
                    <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"/>
                        <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"/>
                    </svg>
                </button>
            </div>
        </template>

        <script>
        let socket;
        let pingInterval;
        let queuedImageIds = new Set(); // Track images that user has queued

        // Initialize WebSocket connection
        function initWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}/ws/`;

            socket = new WebSocket(wsUrl);

            socket.onopen = function(e) {
                logMessage('Connected', 'success');

                // Start ping interval (every 5 seconds)
                pingInterval = setInterval(() => {
                    if (socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({ type: 'ping' }));
                        logMessage('Sent: Ping', 'sent');
                    }
                }, 5000);

                // Request initial images list
                socket.send(JSON.stringify({ type: 'get_images' }));
            };

            socket.onmessage = function(event) {
                const data = JSON.parse(event.data);

                if (data.type === 'pong') {
                    logMessage('Received: Pong', 'received');
                } else if (data.type === 'connection') {
                    logMessage(`Received: ${data.message}`, 'received');
                } else if (data.type === 'image_update') {
                    logMessage(`Received: ${data.message}`, 'received');
                    refreshImageList();

                    // Automatically preview processed image when completed
                    if (data.processed_image && data.image_id) {
                        viewImage(data.processed_image, `Processed Image #${data.image_id}`);
                    }
                } else if (data.type === 'images_list') {
                    updateImageList(data.images);
                }
            };

            socket.onerror = function(error) {
                logMessage(`WebSocket Error: ${error}`, 'error');
            };

            socket.onclose = function(event) {
                logMessage('WebSocket connection closed', 'error');
                clearInterval(pingInterval);

                // Attempt to reconnect after 3 seconds
                setTimeout(initWebSocket, 3000);
            };
        }

        // Log message to the right panel
        function logMessage(message, type = 'info') {
            const messageLog = document.getElementById('messageLog');
            const timestamp = new Date().toLocaleTimeString();
            const colorClass = {
                'success': 'text-green-600',
                'error': 'text-red-600',
                'sent': 'text-blue-600',
                'received': 'text-purple-600',
                'info': 'text-gray-700'
            }[type] || 'text-gray-700';

            const messageDiv = document.createElement('div');
            messageDiv.className = `${colorClass} mb-2`;
            messageDiv.innerHTML = `<span class="text-gray-500">[${timestamp}]</span> ${message}`;

            messageLog.appendChild(messageDiv);
            messageLog.scrollTop = messageLog.scrollHeight;
        }

        // Upload multiple files
        async function uploadFiles() {
            const fileInput = document.getElementById('fileInput');
            const files = fileInput.files;

            if (files.length === 0) {
                alert('Please select at least one file');
                return;
            }

            logMessage(`Uploading ${files.length} file(s)...`, 'info');

            let uploadedCount = 0;
            let lastUploadedImage = null;

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const formData = new FormData();
                formData.append('image', file);

                try {
                    const response = await fetch('/upload/', {
                        method: 'POST',
                        body: formData
                    });

                    const data = await response.json();

                    if (response.ok) {
                        uploadedCount++;
                        logMessage(`File uploaded: ${file.name}`, 'success');
                        lastUploadedImage = data;
                    } else {
                        logMessage(`Upload failed for ${file.name}: ${data.error}`, 'error');
                    }
                } catch (error) {
                    logMessage(`Upload error for ${file.name}: ${error}`, 'error');
                }
            }

            // Clear input and refresh list
            fileInput.value = '';
            refreshImageList();

            // Preview the last uploaded image
            if (lastUploadedImage && lastUploadedImage.original_image) {
                viewImage(lastUploadedImage.original_image, `Original Image #${lastUploadedImage.id}`);
            }

            logMessage(`Upload complete: ${uploadedCount}/${files.length} file(s) uploaded successfully`, 'info');
        }

        // Process image
        async function processImage(imageId, buttonElement) {
            // Mark as queued
            queuedImageIds.add(imageId);

            // Refresh UI to show "Queued" state
            refreshImageList();

            try {
                const response = await fetch(`/process/${imageId}/`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (response.ok) {
                    // Log the simulated delay
                    if (data.simulated_delay) {
                        logMessage(`Image #${imageId} queued (simulated delay: ${data.simulated_delay})`, 'info');
                    }
                } else {
                    logMessage(`Processing failed: ${data.error}`, 'error');
                    // Remove from queued on failure
                    queuedImageIds.delete(imageId);
                    refreshImageList();
                }
            } catch (error) {
                logMessage(`Processing error: ${error}`, 'error');
                // Remove from queued on error
                queuedImageIds.delete(imageId);
                refreshImageList();
            }
        }

        // Process all pending images
        async function processAll() {
            try {
                const response = await fetch('/process-all/', {
                    method: 'POST'
                });

                const data = await response.json();

                if (response.ok) {
                    const delayInfo = data.simulated_delay ? ` (simulated delay: ${data.simulated_delay} each)` : '';
                    logMessage(`Processing ${data.count} image(s)${delayInfo}`, 'success');
                    // Mark all processed IDs as queued
                    if (data.image_ids) {
                        data.image_ids.forEach(id => queuedImageIds.add(id));
                    }
                    refreshImageList();
                } else {
                    logMessage(`Process all failed: ${data.error}`, 'error');
                }
            } catch (error) {
                logMessage(`Process all error: ${error}`, 'error');
            }
        }

        // Delete image
        async function deleteImage(imageId) {
            try {
                const response = await fetch(`/delete/${imageId}/`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (response.ok) {
                    logMessage(`Image ${imageId} deleted`, 'success');
                    queuedImageIds.delete(imageId); // Remove from queued set
                    refreshImageList();
                } else {
                    logMessage(`Delete failed: ${data.error}`, 'error');
                }
            } catch (error) {
                logMessage(`Delete error: ${error}`, 'error');
            }
        }

        // Replay image (duplicate)
        async function replayImage(imageId) {
            try {
                const response = await fetch(`/replay/${imageId}/`, {
                    method: 'POST'
                });

                const data = await response.json();

                if (response.ok) {
                    logMessage(`Image ${imageId} duplicated as #${data.id}`, 'success');
                    refreshImageList();
                } else {
                    logMessage(`Replay failed: ${data.error}`, 'error');
                }
            } catch (error) {
                logMessage(`Replay error: ${error}`, 'error');
            }
        }

        // Open image preview
        function viewImage(imageUrl, caption) {
            const panel = document.getElementById('imagePreviewPanel');
            const previewImage = document.getElementById('previewImage');
            const previewCaption = document.getElementById('imagePreviewCaption');

            previewImage.src = imageUrl;
            previewCaption.textContent = caption;
            panel.classList.remove('hidden');
        }

        // Close image preview
        function closePreview() {
            const panel = document.getElementById('imagePreviewPanel');
            panel.classList.add('hidden');
        }

        // Refresh image list
        async function refreshImageList() {
            try {
                const response = await fetch('/images/');
                const data = await response.json();
                updateImageList(data.images);
            } catch (error) {
                console.error('Error fetching images:', error);
            }
        }

        // Update image list display
        function updateImageList(images) {
            const imageList = document.getElementById('imageList');
            imageList.innerHTML = '';

            if (images.length === 0) {
                imageList.innerHTML = '<p class="text-gray-500">No images uploaded yet</p>';
                return;
            }

            const template = document.getElementById('imageItemTemplate');

            images.forEach(image => {
                const clone = template.content.cloneNode(true);
                const item = clone.querySelector('div');

                // Set image ID and filename
                const idSpan = clone.querySelector('.image-id');
                idSpan.textContent = `#${image.id}`;

                const filenameSpan = clone.querySelector('.image-filename');
                const filename = image.filename || 'unknown';
                const displayName = filename.length > 20 ? filename.substring(0, 20) + '...' : filename;
                filenameSpan.textContent = displayName;
                filenameSpan.title = filename;

                // Set status badge and background
                const statusSpan = clone.querySelector('.image-status');
                const itemDiv = clone.querySelector('.image-item');
                const isQueued = queuedImageIds.has(image.id);

                if (image.status === 'pending' && !isQueued) {
                    // Default state: no status badge
                    statusSpan.remove();
                } else if (image.status === 'pending' && isQueued) {
                    // User clicked but not yet processing
                    statusSpan.className = 'bg-yellow-100 text-yellow-800 text-xs font-medium px-2 py-0.5 rounded';
                    statusSpan.textContent = 'Queued';
                } else if (image.status === 'processing') {
                    // Remove from queued set if present
                    queuedImageIds.delete(image.id);
                    statusSpan.className = 'bg-blue-100 text-blue-800 text-xs font-medium px-2 py-0.5 rounded';
                    statusSpan.textContent = 'Processing...';
                } else if (image.status === 'completed') {
                    // Remove from queued set if present
                    queuedImageIds.delete(image.id);
                    // Remove status badge and change background to green
                    statusSpan.remove();
                    itemDiv.classList.remove('bg-gray-50');
                    itemDiv.classList.add('bg-green-100');
                }

                // Configure buttons
                const sourceBtn = clone.querySelector('.btn-source');
                const resultBtn = clone.querySelector('.btn-result');
                const replayBtn = clone.querySelector('.btn-replay');
                const processBtn = clone.querySelector('.btn-process');
                const deleteBtn = clone.querySelector('.btn-delete');

                // Source button
                if (image.original_image) {
                    sourceBtn.classList.remove('hidden');
                    sourceBtn.onclick = () => viewImage(image.original_image, `Original Image #${image.id}`);
                }

                // Result button
                if (image.processed_image) {
                    resultBtn.classList.remove('hidden');
                    resultBtn.onclick = () => viewImage(image.processed_image, `Processed Image #${image.id}`);
                }

                // Replay button
                replayBtn.onclick = () => replayImage(image.id);

                // Process button
                if (image.status === 'pending' && !isQueued) {
                    // Default state: show green play button
                    processBtn.classList.remove('hidden');
                    processBtn.onclick = (event) => processImage(image.id, event.currentTarget);
                } else if ((image.status === 'pending' && isQueued) || image.status === 'processing') {
                    // Queued or processing: show gray disabled hourglass
                    processBtn.classList.remove('hidden');
                    processBtn.disabled = true;
                    processBtn.classList.remove('bg-green-500', 'hover:bg-green-600');
                    processBtn.classList.add('bg-gray-400', 'cursor-not-allowed', 'opacity-60');
                    processBtn.innerHTML = `
                        <svg xmlns="http://www.w3.org/2000/svg" class="w-4 h-4" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M6 2h12v6l-6 6 6 6v6H6v-6l6-6-6-6V2z"/>
                        </svg>
                    `;
                }
                // If completed, button stays hidden (default hidden state)

                // Delete button
                deleteBtn.onclick = () => deleteImage(image.id);

                imageList.appendChild(clone);
            });
        }

        // Close preview with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closePreview();
            }
        });

        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            initWebSocket();
            refreshImageList();
        });
        </script>
    </body>
</html>
